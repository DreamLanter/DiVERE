name: Build DiVERE Application (PyInstaller)

on:
  push:
    branches: ['main']
    tags: ['v*']
  workflow_dispatch:
  
permissions:
  contents: write
  
jobs:
  build:
    runs-on: ${{ matrix.os }}
    defaults:
      run:
        shell: bash
    strategy:
      matrix:
        include:
          - os: macos-14
            platform: macos
            arch: arm64
            extension: ''
          - os: macos-13
            platform: macos
            arch: x64
            extension: ''
          - os: windows-latest
            platform: windows
            arch: x64
            extension: .exe

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Extract version from package (__init__.py)
      run: |
        VERSION_RAW=$(python - <<'PY'
        import re, pathlib
        p = pathlib.Path('divere/__init__.py').read_text(encoding='utf-8')
        m = re.search(r"__version__\s*=\s*['\"]([^'\"]+)['\"]", p)
        print(m.group(1) if m else "")
        PY
        )
        if [ -z "$VERSION_RAW" ]; then echo "::error::Version not found in divere/__init__.py"; exit 1; fi
        echo "VERSION=$VERSION_RAW" >> $GITHUB_ENV
        echo "VERSION_TAG=v$VERSION_RAW" >> $GITHUB_ENV

    - name: Verify tag matches version (only on tag builds)
      if: startsWith(github.ref, 'refs/tags/')
      run: |
        if [ "${GITHUB_REF_NAME}" != "v${{ env.VERSION }}" ]; then
          echo "::error::Git tag (${GITHUB_REF_NAME}) must equal v${{ env.VERSION }} from divere/__init__.py"; exit 1;
        fi

    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install system dependencies (macOS)
      if: matrix.platform == 'macos'
      run: |
        brew install openssl readline sqlite3 xz zlib libomp

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip wheel setuptools build
        # 安装项目本身及其依赖（从 pyproject.toml）
        pip install -e .
        # GPU 相关可选依赖
        if [ "${{ matrix.platform }}" = "macos" ]; then
          pip install --extra-index-url https://pypi.org/simple/ "pyobjc-framework-Metal" "pyobjc-framework-MetalPerformanceShaders" || true
        fi
        # Windows 上可选尝试安装 CuPy（CUDA）
        if [ "${{ matrix.platform }}" = "windows" ]; then
          echo "Attempting to install CuPy (CUDA) wheels..."
          pip install cupy-cuda12x || \
          pip install cupy-cuda11x || \
          pip install cupy-cuda102 || \
          echo "CuPy CUDA wheels not installed (no GPU/driver on runner)."
        fi
        echo "--- Installed packages ---"
        pip list | sed -n '1,200p'
        echo "--------------------------"

    - name: Check required imports
      run: |
        python - <<'PY'
        import importlib, sys
        required = [
          'PySide6', 'numpy', 'cv2', 'PIL', 'scipy', 'imageio', 'colour', 'onnxruntime', 'pyopencl',
          'tifffile', 'imagecodecs', 'cma'
        ]
        missing = []
        for m in required:
            try:
                importlib.import_module(m)
            except Exception as e:
                missing.append((m, repr(e)))
        if missing:
            print('Missing modules:')
            for name, err in missing:
                print(f'- {name}: {err}')
            sys.exit(1)
        print('All required imports are available.')
        PY

    - name: Install PyInstaller
      run: |
        pip install pyinstaller pyinstaller-hooks-contrib
        python -c "import PyInstaller; print('PyInstaller', PyInstaller.__version__)"

    - name: Prepare app icon (macOS)
      if: matrix.platform == 'macos'
      run: |
        set -e
        ICON_PNG="divere/assets/icon.png"
        if [ ! -f "$ICON_PNG" ]; then echo "::warning::icon.png not found at $ICON_PNG"; exit 0; fi
        mkdir -p icons/icon.iconset
        sips -z 16 16   "$ICON_PNG" --out icons/icon.iconset/icon_16x16.png
        sips -z 32 32   "$ICON_PNG" --out icons/icon.iconset/icon_16x16@2x.png
        sips -z 32 32   "$ICON_PNG" --out icons/icon.iconset/icon_32x32.png
        sips -z 64 64   "$ICON_PNG" --out icons/icon.iconset/icon_32x32@2x.png
        sips -z 128 128 "$ICON_PNG" --out icons/icon.iconset/icon_128x128.png
        sips -z 256 256 "$ICON_PNG" --out icons/icon.iconset/icon_128x128@2x.png
        sips -z 256 256 "$ICON_PNG" --out icons/icon.iconset/icon_256x256.png
        sips -z 512 512 "$ICON_PNG" --out icons/icon.iconset/icon_256x256@2x.png
        sips -z 512 512 "$ICON_PNG" --out icons/icon.iconset/icon_512x512.png
        sips -z 1024 1024 "$ICON_PNG" --out icons/icon.iconset/icon_512x512@2x.png
        iconutil -c icns -o icons/app.icns icons/icon.iconset
        ls -la icons || true

    - name: Prepare app icon (Windows)
      if: matrix.platform == 'windows'
      shell: pwsh
      run: |
        $png = "divere/assets/icon.png"
        if (!(Test-Path $png)) { Write-Host "::warning::icon.png not found at $png"; exit 0 }
        New-Item -ItemType Directory -Force -Path icons | Out-Null
        $code = 'from PIL import Image; from pathlib import Path; p=Path("divere/assets/icon.png"); out=Path("icons/app.ico"); im=Image.open(p); im.save(out, sizes=[(16,16),(32,32),(48,48),(64,64),(128,128),(256,256)]); print("ICO written to", out)'
        python -c $code
        dir icons

    - name: Build with PyInstaller
      run: |
        rm -rf build dist *.spec || true
        # PyInstaller --add-data 在 Windows 使用分号 ;，在 macOS 使用冒号 :
        DATA_SEP=':'
        if [ "${{ matrix.platform }}" = "windows" ]; then DATA_SEP=';'; fi
        ICON_ARG=""
        if [ "${{ matrix.platform }}" = "macos" ] && [ -f icons/app.icns ]; then ICON_ARG="--icon icons/app.icns"; fi
        if [ "${{ matrix.platform }}" = "windows" ] && [ -f icons/app.ico ]; then ICON_ARG="--icon icons/app.ico"; fi
        python -m PyInstaller \
          -y --clean --noconfirm \
          --windowed \
          --name "DiVERE" \
          ${ICON_ARG} \
          --add-data "divere/config${DATA_SEP}config" \
          --add-data "divere/assets${DATA_SEP}assets" \
          --add-data "divere/models${DATA_SEP}models" \
          --collect-all onnxruntime \
          --collect-all pyopencl \
          --collect-all cupy \
          --collect-all tifffile \
          --collect-all imagecodecs \
          --hidden-import "scipy.interpolate" \
          --hidden-import "scipy.optimize" \
          --hidden-import "scipy.ndimage" \
          --hidden-import "tifffile" \
          --hidden-import "imagecodecs" \
          --hidden-import "cma" \
          divere/__main__.py
        echo "✅ PyInstaller build completed"

    - name: Ensure resources adjacent to exe (Windows)
      if: matrix.platform == 'windows'
      shell: pwsh
      run: |
        $distRoot = "dist"
        $appDir = Join-Path $distRoot "DiVERE"
        if (!(Test-Path $appDir)) {
          Write-Error "DiVERE folder not found under dist"
          Get-ChildItem -Force $distRoot | Format-List
          exit 1
        }
        # Ensure config and models exist next to DiVERE.exe
        $cfg = Join-Path $appDir "config"
        $mdl = Join-Path $appDir "models"
        $ast = Join-Path $appDir "assets"
        if (!(Test-Path $cfg)) { New-Item -ItemType Directory -Path $cfg | Out-Null }
        if (!(Test-Path $mdl)) { New-Item -ItemType Directory -Path $mdl | Out-Null }
        if (!(Test-Path $ast)) { New-Item -ItemType Directory -Path $ast | Out-Null }
        # Copy from repo if PyInstaller didn't place them
        Copy-Item -Recurse -Force "divere/config/*" $cfg -ErrorAction SilentlyContinue
        Copy-Item -Recurse -Force "divere/models/*" $mdl 2>$null
        Copy-Item -Recurse -Force "divere/assets/*" $ast 2>$null

    - name: Verify bundle contents (Windows)
      if: matrix.platform == 'windows'
      shell: pwsh
      run: |
        $appDir = "dist/DiVERE"
        $exe = Join-Path $appDir "DiVERE.exe"
        if (!(Test-Path $exe)) { Write-Error "Executable not found: $exe"; exit 1 }
        
        Write-Host "--- Verifying directory structure in bundle ---"
        $requiredDirs = @(
          "config",
          "config/colorspace",
          "config/curves", 
          "config/matrices",
          "models",
          "assets"
        )
        
        # 验证目录结构存在
        $missingDirs = 0
        foreach ($dir in $requiredDirs) {
          $fullPath = Join-Path $appDir $dir
          if (!(Test-Path $fullPath)) {
            Write-Error "Missing directory: $dir"
            $missingDirs = 1
          } else {
            Write-Host "✅ Directory exists: $dir"
          }
        }
        
        if ($missingDirs -ne 0) {
          Write-Error "Required directories missing in app bundle"; exit 1
        }
        
        Write-Host "--- Verifying file types and counts ---"
        # 验证关键文件类型存在（不指定具体文件名）
        $fileChecks = @(
          @{Dir="config"; Pattern="*.json"; MinCount=1},
          @{Dir="config/colorspace/icc"; Pattern="*.icc"; MinCount=3},
          @{Dir="config/curves"; Pattern="*.json"; MinCount=1},
          @{Dir="config/matrices"; Pattern="*.json"; MinCount=1},
          @{Dir="models"; Pattern="*.onnx"; MinCount=1},
          @{Dir="assets"; Pattern="*.png"; MinCount=1}
        )
        
        $missingFiles = 0
        foreach ($check in $fileChecks) {
          $fullPath = Join-Path $appDir $check.Dir
          $files = Get-ChildItem -Path $fullPath -Name $check.Pattern
          $fileCount = $files.Count
          if ($fileCount -lt $check.MinCount) {
            Write-Error "Directory $($check.Dir) has only $fileCount files matching $($check.Pattern) (minimum: $($check.MinCount))"
            $missingFiles = 1
          } else {
            Write-Host "✅ $($check.Dir): $fileCount files matching $($check.Pattern) (minimum: $($check.MinCount))"
          }
        }
        
        if ($missingFiles -ne 0) {
          Write-Error "Required file types missing in app bundle"; exit 1
        }
        
        Write-Host "✅ Directory structure and file types verification passed."
        
        Write-Host "--- Listing actual files for reference ---"
        foreach ($dir in $requiredDirs) {
          $fullPath = Join-Path $appDir $dir
          Write-Host "Files in $($dir):"
          Get-ChildItem -Path $fullPath -File | Select-Object -First 10 | ForEach-Object { Write-Host "  $($_.Name)" }
          Write-Host ""
        }

    - name: Relocate resources into Contents/MacOS (for runtime compatibility)
      if: matrix.platform == 'macos'
      run: |
        app_bundle=$(find dist -type d -name "*.app" | head -1)
        if [ -z "$app_bundle" ]; then
          echo "::error::No .app bundle found after build." && exit 1
        fi
        resources_dir="$app_bundle/Contents/Resources"
        macos_dir="$app_bundle/Contents/MacOS"
        mkdir -p "$macos_dir"
        if [ -d "$resources_dir/config" ]; then
          rm -rf "$macos_dir/config"
          cp -a "$resources_dir/config" "$macos_dir/config"
        fi
        if [ -d "$resources_dir/models" ]; then
          rm -rf "$macos_dir/models"
          cp -a "$resources_dir/models" "$macos_dir/models"
        fi
        if [ -d "$resources_dir/assets" ]; then
          rm -rf "$macos_dir/assets"
          cp -a "$resources_dir/assets" "$macos_dir/assets"
        fi
        echo "Relocated resources to Contents/MacOS"

    - name: Ad-hoc sign app bundle (deep)
      if: matrix.platform == 'macos'
      run: |
        app_bundle=$(find dist -type d -name "*.app" | head -1)
        if [ -z "$app_bundle" ]; then
          echo "::error::No .app bundle found for codesign." && exit 1
        fi
        echo "Codesigning (ad-hoc) $app_bundle"
        codesign --force --deep -s - "$app_bundle" || true
        echo "Verify codesign (may show 'rejected' due to no notarization)"
        codesign -dv "$app_bundle" 2>&1 | sed -n '1,200p'

    - name: Verify bundle contents (macOS)
      if: matrix.platform == 'macos'
      run: |
        app_bundle=$(find dist -type d -name "*.app" | head -1)
        if [ -z "$app_bundle" ]; then
          echo "::error::No .app bundle found." && exit 1
        fi
        echo "App bundle: $app_bundle"

        echo "--- Listing key dylib files in bundle (onnxruntime) ---"
        find "$app_bundle" -name "*onnxruntime*.dylib" | sed -n '1,80p' || true

        echo "--- Verifying directory structure in bundle ---"
        required_dirs=(
          "Contents/MacOS/config"
          "Contents/MacOS/config/colorspace"
          "Contents/MacOS/config/curves"
          "Contents/MacOS/config/matrices"
          "Contents/MacOS/models"
          "Contents/MacOS/assets"
        )
        
        # 验证目录结构存在
        missing_dirs=0
        for dir in "${required_dirs[@]}"; do
          if [ ! -d "$app_bundle/$dir" ]; then
            echo "::error::Missing directory: $dir"
            missing_dirs=1
          else
            echo "✅ Directory exists: $dir"
          fi
        done
        
        if [ $missing_dirs -ne 0 ]; then
          echo "Required directories missing in app bundle" && exit 1
        fi
        
        echo "--- Verifying file types and counts ---"
        # 验证关键文件类型存在（不指定具体文件名）
        file_checks=(
          "Contents/MacOS/config:*.json:1"
          "Contents/MacOS/config/colorspace/icc:*.icc:3"
          "Contents/MacOS/config/curves:*.json:1"
          "Contents/MacOS/config/matrices:*.json:1"
          "Contents/MacOS/models:*.onnx:1"
          "Contents/MacOS/assets:*.png:1"
        )
        
        missing_files=0
        for check in "${file_checks[@]}"; do
          IFS=':' read -r dir pattern min_count <<< "$check"
          file_count=$(find "$app_bundle/$dir" -name "$pattern" | wc -l)
          if [ $file_count -lt $min_count ]; then
            echo "::error::Directory $dir has only $file_count files matching $pattern (minimum: $min_count)"
            missing_files=1
          else
            echo "✅ $dir: $file_count files matching $pattern (minimum: $min_count)"
          fi
        done
        
        if [ $missing_files -ne 0 ]; then
          echo "Required file types missing in app bundle" && exit 1
        fi
        
        echo "✅ Directory structure and file types verification passed."
        
        echo "--- Listing actual files for reference ---"
        for dir in "${required_dirs[@]}"; do
          echo "Files in $dir:"
          find "$app_bundle/$dir" -type f | head -10 | sed 's/^/  /'
          echo ""
        done

    - name: Package macOS App (zip)
      if: matrix.platform == 'macos'
      run: |
        app_bundle=$(find dist -type d -name "*.app" | head -1)
        cd dist
        ditto -c -k --sequesterRsrc --keepParent "$(basename "$app_bundle")" "DiVERE-${{ env.VERSION_TAG }}-${{ matrix.platform }}-${{ matrix.arch }}.zip"

    - name: Upload build artifact (macOS)
      if: matrix.platform == 'macos'
      uses: actions/upload-artifact@v4
      with:
        name: DiVERE-${{ env.VERSION_TAG }}-${{ matrix.platform }}-${{ matrix.arch }}
        path: dist/DiVERE-${{ env.VERSION_TAG }}-${{ matrix.platform }}-${{ matrix.arch }}.zip

    - name: Upload build artifact (Windows)
      if: matrix.platform == 'windows'
      uses: actions/upload-artifact@v4
      with:
        name: DiVERE-${{ env.VERSION_TAG }}-${{ matrix.platform }}-${{ matrix.arch }}
        path: dist/DiVERE

  build-packages:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Extract version from package
      run: |
        VERSION_RAW=$(python3 - <<'PY'
        import re, pathlib
        p = pathlib.Path('divere/__init__.py').read_text(encoding='utf-8')
        m = re.search(r"__version__\s*=\s*['\"]([^'\"]+)['\"]", p)
        print(m.group(1) if m else "")
        PY
        )
        if [ -z "$VERSION_RAW" ]; then echo "::error::Version not found"; exit 1; fi
        echo "VERSION=$VERSION_RAW" >> $GITHUB_ENV
        echo "VERSION_TAG=v$VERSION_RAW" >> $GITHUB_ENV

    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip build wheel setuptools

    - name: Build Python packages
      run: |
        python -m build --sdist --wheel --outdir dist/

    - name: Verify package contents
      run: |
        ls -la dist/
        # Check that both .whl and .tar.gz were created
        if [ ! -f dist/divere-${{ env.VERSION }}*.whl ]; then
          echo "::error::Wheel package not found"
          exit 1
        fi
        if [ ! -f dist/divere-${{ env.VERSION }}*.tar.gz ]; then
          echo "::error::Source package not found"
          exit 1
        fi
        # Check wheel contents
        python -m zipfile -l dist/divere-${{ env.VERSION }}*.whl | head -20

    - name: Upload Python packages
      uses: actions/upload-artifact@v4
      with:
        name: python-packages-${{ env.VERSION_TAG }}
        path: dist/

  release:
    permissions:
      contents: write
      packages: write
    needs: [build, build-packages]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Set VERSION_TAG from git tag
        run: echo "VERSION_TAG=${GITHUB_REF_NAME}" >> $GITHUB_ENV

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release assets
        run: |
          set -e
          ls -la artifacts || true
          
          # Windows artifact is a folder; zip it for release
          for dir in artifacts/DiVERE-${{ env.VERSION_TAG }}-windows-*; do
            if [ -d "$dir" ]; then
              zipname="$dir.zip"
              (cd "$dir" && zip -r ../"$(basename "$zipname")" .)
            fi
          done
          
          # Move all assets to top-level release-assets
          mkdir -p release-assets
          
          # Move binary zips
          find artifacts -name "*.zip" -maxdepth 2 -print -exec mv {} release-assets/ \;
          
          # Move Python packages
          if [ -d "artifacts/python-packages-${{ env.VERSION_TAG }}" ]; then
            mv artifacts/python-packages-${{ env.VERSION_TAG }}/* release-assets/
          fi
          
          echo "Release assets:" && ls -la release-assets

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.VERSION_TAG }}
          name: DiVERE ${{ env.VERSION_TAG }}
          draft: false
          prerelease: false
          files: |
            release-assets/*.zip
            release-assets/*.whl
            release-assets/*.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
